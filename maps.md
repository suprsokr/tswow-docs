# Creating Maps and Continents in TSWoW

## Table of Contents
- [Overview](#overview)
- [Understanding the Architecture](#understanding-the-architecture)
- [Quick Start: Your First Map](#quick-start-your-first-map)
- [Understanding ADT Files](#understanding-adt-files)
- [Client-Side vs Server-Side Data](#client-side-vs-server-side-data)
- [The Map Abstraction](#the-map-abstraction)
- [Creating Areas and Zones](#creating-areas-and-zones)
- [World Map UI Configuration](#world-map-ui-configuration)
- [Understanding Boundary Coordinates](#understanding-boundary-coordinates)
- [Working with Minimap Textures](#working-with-minimap-textures)
- [Advanced: Map Overlays](#advanced-map-overlays)
- [Collision Data: MMaps and VMaps](#collision-data-mmaps-and-vmaps)
- [Reference Example](#reference-example)
- [Troubleshooting](#troubleshooting)

---

## Overview

This guide covers how TSWoW handles "the other half" of map creation beyond terrain editing. While terrain sculpting happens in Noggit ([github.com/wowdev/noggit3](https://github.com/wowdev/noggit3)), TSWoW manages:

- Generating empty ADT template files from a base ADT
- Configuring client-side data (DBC files) for map display
- Setting up server-side data for map loading
- Packaging assets into MPQ archives
- Generating collision data (mmaps/vmaps) for pathfinding

Not familiar with TSWoW generally yet? See [tswow.github.io/tswow-wiki/install/](https://tswow.github.io/tswow-wiki/install/)

---

## Understanding the Architecture

### ADT Files: The Foundation

**ADT** (Area Data Tile) files are the actual terrain chunk files that make up WoW maps.

- File format: Binary `.adt` files
- Technical specification: [wowdev.wiki/ADT/v18](https://wowdev.wiki/ADT/v18)
- Contents: heightmap, textures, vertex colors, liquids, object references, lighting
- Size: 533.33 yards × 533.33 yards per tile
- Grid: Maps can have up to 64×64 ADT tiles (most maps use only a subset)

**Key point:** ADTs are the "real" files. Everything else (DBC entries, SQL rows) references them.

### WDT Files: The Index

**WDT** (World Data Table) files serve as an index listing which ADT tiles exist for a map.

- Contains a 64×64 bitmap (0 = no tile, 1 = tile exists)
- Contains map flags (instance type, global WMO support, etc.)
- One WDT file per map directory
- Automatically generated by TSWoW's ADT creator

### TSWoW's Three-Layer Architecture

**Layer 1: Assets (File System)**
```
modules/your-mod/assets/
├── world/maps/mapname/
│   ├── mapname.wdt              ← WDT index file
│   ├── mapname_32_32.adt        ← ADT terrain tiles
│   └── mapname_32_33.adt
├── Interface/WorldMap/
│   └── MapName.blp              ← Minimap textures
└── vmaps/                        ← Generated collision data (WMO/M2)
```

**Layer 2: Client-Side Data (DBC Files)**
- `Map.dbc` - Map metadata (ID, name, directory, loading screen)
- `WorldMapContinent.dbc` - Continent display settings
- `WorldMapArea.dbc` - Zone minimap configurations  
- `AreaTable.dbc` - Zone/area definitions

Purpose: Tells the client how to interpret and display ADT files. Generated from your datascripts during `build data`.

**Layer 3: Server-Side Data (SQL + Extracted Data)**
- `instance_template` (SQL) - Instance configuration for dungeons/raids
- `mmaps/` - Navigation meshes for NPC pathfinding
- `vmaps/` - Collision data extracted from WMOs/M2s

The server reads ADT files directly for basic terrain, and uses mmaps/vmaps for gameplay.

### The "Map" Abstraction

**Important:** "Map" in TSWoW is an abstraction, not a single file type.

When you call `std.Maps.create()`, TSWoW creates and manages:
- Entry in `Map.dbc` (client-side metadata)
- WDT file (if generating ADTs)
- Folder structure in `assets/world/maps/`
- Optional SQL entries (for instances)

Think of it as: **Map = DBC entry + ADT directory + metadata**

### ADT Generation: The Template System

TSWoW doesn't create ADT files from scratch. Instead:

1. **Downloads a base ADT template** during TSWoW installation
   - URL: [github.com/tswow/misc/releases/download/adt-template/source.adt](https://github.com/tswow/misc/releases/download/adt-template/source.adt)
   - This is a valid, empty ADT file with all required chunks
   
2. **Uses `adtcreator` to clone the template**
   - Source: `misc/adt-creator/` (C++ tool, compiled during TSWoW build)
   - Takes the base ADT and copies it to create new tiles
   - Adjusts coordinates and chunk headers for each tile position
   - Creates the WDT index automatically

3. **You edit the resulting ADTs in Noggit**
   - Noggit modifies the generated ADT files
   - Add terrain height, textures, objects, liquids, etc.
   - TSWoW's ADTs provide the valid file structure

TSWoW generates the ADT structure, Noggit sculpts the terrain.

---

## Quick Start: Your First Map

### Step 1: Create the Map Entry

```typescript
// In datascripts/mymap.ts
import { std } from "wow/wotlk";

export const MY_MAP = std.Maps
    .create('my-module', 'my-first-map')
    .Directory.set('myfirstmap')
    .Name.enGB.set('My First Map')
```

**What this does:**
- Creates entry in `Map.dbc` with an auto-generated unique ID
- Sets the directory name (must match the asset folder path)
- Sets the display name shown in loading screens and UI

### Step 2: Generate ADT Template Files

```typescript
MY_MAP.Tiles.add('my-module', [[30, 30, 34, 34, 'myfirstmap']])
```

**What happens:**
1. TSWoW reads the base ADT template from `bin/source.adt`
2. Calls `bin/adt-creator/adtcreator.exe` with parameters:
   - Input: base template ADT
   - Output directory: `modules/my-module/assets/world/maps/myfirstmap/`
   - Map name: `myfirstmap`
   - Coordinate range: X: 30-34, Y: 30-34
3. Generates files:
   - `myfirstmap.wdt` - WDT index with 64×64 bitmap marking tiles 30-34 as present
   - `myfirstmap_30_30.adt` through `myfirstmap_34_34.adt` - 25 ADT files (5×5 grid)
4. Each ADT is a clone of the base template with coordinate headers adjusted

**Parameters explained:**
- `'my-module'` - Which module's assets folder to create files in
- `[30, 30, 34, 34, 'myfirstmap']` - Array format: `[minX, minY, maxX, maxY, optionalTeleportName]`
- Coordinates are ADT tile indices (range: 0-63, world center at 32,32)
- Optional 5th parameter creates a `.tele myfirstmap` GM command

**Note:** These generated ADTs are empty, flat terrain. You must edit them in Noggit to create actual landscapes, add textures, place objects, etc.

### Step 3: Build Data and Client

```bash
build data    # Generates DBC files from your datascripts
build client  # Packages DBCs and assets into MPQ archives
```

**What `build data` does:**
- Executes your TypeScript datascripts
- Writes updated `Map.dbc` with your map entry
- Calls ADT creator if `.Tiles.add()` was used
- Generates `AreaTable.dbc` entries if you created areas
- Updates all affected DBC files

**What `build client` does:**
- Packages DBC files into `patch-x.MPQ` archives
- Packages ADT files and textures into map-specific MPQs
- Creates client update package in `bin/package/`
- Client reads these MPQs on launch

### Step 4: Start Server and Test

```bash
start
# In-game: .tele myfirstmap
```

**Expected result:**
- Successfully teleport to the center of your ADT range
- See flat, empty terrain with basic default texturing
- Terrain collision works (can walk, not fall through world)
- Map is ready to edit in Noggit

---

## Understanding ADT Files

### ADT File Format

ADT files use a binary chunk-based format (similar to IFF/RIFF):
- Technical details: [wowdev.wiki/ADT/v18](https://wowdev.wiki/ADT/v18)
- Main chunks: `MVER` (version), `MHDR` (header), `MCIN` (chunk index), `MCNK` (terrain chunks)
- Each MCNK chunk: 33.33 yards × 33.33 yards sub-section

### The 64×64 Grid System

```
ADT Coordinate System (0,0 to 63,63):
    0   1   2  ...  31  32  33  ...  62  63
  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
0 │   │   │   │   │   │   │   │   │   │   │
  ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤
1 │   │   │   │   │   │   │   │   │   │   │
  ├───┴───┴───┴───┴───┴───┴───┴───┴───┴───┤
          ...
  ├───┬───┬───┬───┬───┬───┬───┬───┬───┬───┤
32│   │   │   │   │[C]│   │   │   │   │   │  ← Center: (32,32)
  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
```

**Coordinate properties:**
- Maximum: 4,096 possible tiles per map (64×64)
- Most maps use only a subset to save disk space
- World center: ADT coordinate (32, 32) = world coordinate (0, 0)
- Each tile: 533.33333 yards × 533.33333 yards

### World Coordinate System

```typescript
// Convert ADT coordinates to world coordinates
worldX = (32 - adtX) × 533.333333
worldY = (32 - adtY) × 533.333333

// Examples:
// ADT (32, 32) → World (0, 0)
// ADT (30, 30) → World (1066.67, 1066.67)
// ADT (34, 34) → World (-1066.67, -1066.67)
```

**Why this matters:**
- Teleport commands use world coordinates
- Flight paths use world coordinates  
- Object/NPC positions use world coordinates
- You need this conversion to position gameplay elements

### ADT Internal Structure

Each ADT file contains 256 terrain chunks in a 16×16 grid:
- Each chunk: 33.33 yards × 33.33 yards
- Each chunk has its own heightmap (9×9 + 8×8 vertices)
- Each chunk can have multiple texture layers
- Each chunk has one area ID assignment
- Chunks are edited individually in Noggit

### File Naming Convention

```
<MapDirectory>_<X>_<Y>.adt

Examples:
- testmap_32_32.adt          ← Center tile
- testmap_30_34.adt          ← North-west of center
- EasternKingdoms_35_47.adt  ← Stormwind area
```

---

## Client-Side vs Server-Side Data

### Client-Side: DBC Files

**Purpose:** Visual and UI information for rendering and display.

**Map.dbc**
```typescript
std.Maps.create() → Map.dbc entry
```
Fields:
- Map ID (primary key, auto-generated)
- Directory name (e.g., "testmap" - must match folder in assets)
- Map name (localized string for display)
- Instance type (0=none, 1=party dungeon, 2=raid, 3=pvp, 4=arena)
- Loading screen ID reference
- Expansion ID (0=vanilla, 1=TBC, 2=WotLK)
- Flags (uint32 bitmask) - **Note:** Map flags are not well documented for WotLK. Only `MAP_FLAG_DYNAMIC_DIFFICULTY` (0x100) is known to be used in TrinityCore. Other flag values are undocumented and may be unused, reserved, or from later expansions. Most maps use `0` (no flags) or copy flags from an existing map (e.g., `std.Maps.load(0).Flags.get()`).

**AreaTable.dbc**
```typescript
std.Areas.create() → AreaTable.dbc entry
```
Fields:
- Area ID (zone/subzone identifier)
- Map ID (which map this area is on)
- Parent area ID (0 for zones, parent zone ID for subzones)
- Area name (localized)
- Exploration level (for discovery XP)
- Faction (ALLIANCE=2, HORDE=4, CONTESTED=0)
- Ambient sounds, music references

**WorldMapContinent.dbc**
```typescript
WorldMapContinentRegistry.create() → WorldMapContinent.dbc
```
Fields:
- Links Map ID to world map UI display
- ADT boundary coordinates (which tiles to show)
- Display scale and offset (UI positioning)
- Taxi boundary coordinates (flight path system)

**WorldMapArea.dbc**
```typescript
std.WorldMapAreas.create() → WorldMapArea.dbc
```
Fields:
- Zone minimap configuration
- Area ID and Map ID references
- Boundary coordinates (where zone appears on continent map)
- Directory name for minimap texture

### Server-Side: SQL + Extracted Data

**Purpose:** Gameplay functionality and physics.

**SQL Tables:**
```sql
instance_template  -- Only needed for dungeons/raids
```
Fields:
- Map ID
- Parent instance (for linked instances)
- Script name (for custom instance behavior)
- Allow mount flag

**Extracted Collision Data:**
```
data/mmaps/  -- Movement maps (navigation meshes)
  └── <mapID>.mmap, <mapID>_<x>_<y>.mmtile
  
data/vmaps/  -- Visibility maps (WMO/M2 collision)
  └── <mapID>.vmtree, <mapID>_<y>_<x>.vmtile
```

Generated from:
- ADT files (terrain heightmap)
- WMO files (world map objects - buildings)
- M2 files (doodads - trees, rocks, etc.)

Used for:
- NPC pathfinding (mmaps)
- Line-of-sight checks (vmaps)
- Collision detection (vmaps)

### What Each Layer Reads

**Client reads:**
- ADT files → terrain geometry, textures, liquids for rendering
- DBC files → metadata, names, UI configuration
- BLP files → minimap textures for world map UI
- Does NOT use mmaps/vmaps (no collision on client)

**Server reads:**
- ADT files → basic terrain height for physics
- DBC files → map IDs, instance type, area definitions
- MMaps → for NPC pathfinding calculations
- VMaps → for collision and line-of-sight
- SQL → instance configuration and behavior

**Key insight:** Both client and server need ADT and DBC files, but use them for different purposes. The client renders, the server simulates.

---

## The Map Abstraction

### Not a Single File

The `Map` class in TSWoW is a convenience abstraction managing multiple systems:

```typescript
const MAP = std.Maps.create('mod', 'id')
```

**Creates and configures:**
1. Entry in `Map.dbc` with auto-generated ID
2. Folder at `modules/mod/assets/world/maps/<directory>/`
3. Optional WDT + ADT files (if `.Tiles.add()` called)
4. Optional SQL entries (if instance type configured)

### The API Surface

```typescript
std.Maps
  .create(mod, id)                  // Creates Map.dbc entry
  .Directory.set('name')            // Sets asset folder name
  .Name.enGB.set('Display Name')    // Sets localized display name
  .LoadingScreen.setSimple('path')  // Sets loading screen texture
  .Tiles.add(mod, [[coords]])       // Generates ADT template files
  .Type.DUNGEON.set()              // Changes to dungeon (adds SQL)
  .Type.PLAIN.set()                // Plain overworld map (default)
  .Flags.set(value)                // Map flags (uint32) - see note below
  .MaxPlayers.set(count)           // Player limit (instances)
```

### Instance Types Transform the Map

```typescript
// Plain overworld map (default)
MAP.Type.PLAIN.set()
// Result: Map.dbc entry only, no SQL, no special behavior

// Dungeon map
MAP.Type.DUNGEON.set()
// Result: Map.dbc + instance_template SQL row
  .AllowMount.set(false)           // Disable mounts inside
  .Script.set('custom_script')     // C++ script name

// Raid map
MAP.Type.RAID.set()
// Result: Similar to dungeon, different instance type

// Battleground
MAP.Type.BATTLEGROUND.set()
// Result: Map.dbc + battleground_template SQL
```

**Under the hood:** The type property uses TSWoW's `EnumCellTransform` system to change which tables and files are created/modified.

### Relationship to Physical Files

```
std.Maps.create('mod', 'id') execution flow:
    ↓
┌─────────────────────────────────────┐
│ Generate unique ID                  │
│ Create Map.dbc row                  │
│   - ID: 727 (example)               │
│   - Directory: "testmap"            │
│   - InstanceType: 0                 │
│   - Name: "Test Map"                │
└─────────────────────────────────────┘
    ↓
.Tiles.add('mod', [[30,30,34,34]]) call:
    ↓
┌─────────────────────────────────────┐
│ Execute adtcreator                  │
│   Input: bin/source.adt             │
│   Output: modules/mod/assets/...    │
│   Coords: 30-34 in X and Y          │
└─────────────────────────────────────┘
    ↓
Files physically created:
    modules/mod/assets/world/maps/testmap/
        testmap.wdt              (WDT index)
        testmap_30_30.adt        (Empty ADT template)
        testmap_30_31.adt
        testmap_30_32.adt
        ... (25 files total for 5×5 grid)
```

**Conceptual model:** "Map" is not a file format. It's TSWoW's abstraction coordinating DBC entries, file system structure, and optional SQL configuration.

---

## Creating Areas and Zones

### Area Hierarchy

Areas in WoW form a tree structure:

```
Map (e.g., "Eastern Kingdoms", ID=0)
  ├─ Zone 1 (e.g., "Elwynn Forest", ParentArea=0)
  │   ├─ Subzone 1a (e.g., "Goldshire")
  │   └─ Subzone 1b (e.g., "Northshire Abbey")
  └─ Zone 2 (e.g., "Stormwind City", ParentArea=0)
      ├─ Subzone 2a (e.g., "Trade District")
      └─ Subzone 2b (e.g., "Old Town")
```

### Creating a Zone

```typescript
const MY_ZONE = std.Areas
    .create('module', 'zone-id')
    .Name.enGB.set('Zone Name')
    .Map.set(MY_MAP.ID)
    .ExplorationLevel.set(1)
    .Faction.set('CONTESTED')  // ALLIANCE, HORDE, CONTESTED
```

**Result:** Entry in `AreaTable.dbc`

**Properties explained:**

**ExplorationLevel** - Minimum level for discovery experience
- When a player enters this area for the first time, they get XP
- Set to 1 for low-level zones, higher for advanced areas
- Set to 0 to disable discovery XP

**Faction** - Territory ownership
- `CONTESTED` (0) - No faction owns it, both sides co-exist
- `ALLIANCE` (2) - Alliance territory, Horde players auto-flagged for PvP
- `HORDE` (4) - Horde territory, Alliance players auto-flagged for PvP
- Affects guards, flight masters, and PvP flagging

### Creating Subzones

```typescript
const SUBZONE = std.Areas
    .create('module', 'subzone-id')
    .Name.enGB.set('Subzone Name')
    .Map.set(MY_MAP.ID)
    .ParentArea.set(MY_ZONE.ID)  // Links to parent zone
    .ExplorationLevel.set(1)
```

**Hierarchy rules:**
- Subzones reference their parent via `ParentArea`
- Top-level zones have `ParentArea = 0`
- Can nest multiple levels (zone → subzone → sub-subzone)
- Area ID must be unique across entire database

### Assigning Areas to Terrain

**Critical:** Area assignment happens in Noggit, NOT in datascripts!

**The workflow:**
1. Create area IDs in datascripts (writes to `AreaTable.dbc`)
2. Build data (`build data`)
3. Open map in Noggit
4. Select terrain chunks (33.33 yard squares)
5. Assign area ID from dropdown to each chunk
6. Save ADT file

**Technical details:**
- Each ADT contains 256 chunks (16×16 grid)
- Each chunk stores one area ID in its MCNK header (offset 0x3C)
- The area ID is written directly into the ADT binary data
- TSWoW tracks these assignments in `modules/mod/areas.json`

**TSWoW's area management:**
- During builds, TSWoW scans ADT files for area IDs
- Stores mapping: `{modID-areaName: areaID}` in `areas.json`
- If area IDs change, automatically updates ADT files
- Prevents ID conflicts across datascript rebuilds

---

## World Map UI Configuration

### Two Levels of World Map

**1. Continent Map (WorldMapContinent)**
- Shows entire map in one view
- Used for flight paths and overview
- Example: Pressing M in Eastern Kingdoms shows the full continent

**2. Zone Maps (WorldMapArea)**
- Shows individual zones in detail
- Click on continent map to zoom into zone
- Example: Clicking Elwynn Forest zooms to that zone's detailed map

### Configuring a Continent Map

```typescript
import { WorldMapContinentRegistry } from "wow/wotlk/std/Worldmap/WorldMapContinent";

const CONTINENT = WorldMapContinentRegistry
    .create(MY_MAP.ID)
    .ADTBoundary.set(1, 1, 6, 6)          // Which ADT tiles are shown
    .Directory.set('TestMap')              // Minimap BLP name
    .Scale.set(2.5)                        // UI zoom level
    .ContinentOffset.setSpread(70, 70)    // Centers the display
    .World.set(1)                          // 0=Outland, 1=Azeroth world map
```

**Result:** Entry in `WorldMapContinent.dbc`

**Property details:**

**ADTBoundary** - Visible tile range
```typescript
.ADTBoundary.set(minX, minY, maxX, maxY)
// Example: .set(1, 1, 6, 6) shows ADT tiles 1-6 in both X and Y axes
```
Defines which portion of the 64×64 grid is displayed on the world map.

**TaxiBoundary** - Flight path coordinate bounds
```typescript
.TaxiBoundary.setMinimapCoords(
    [adtMinX, adtMinY, adtMaxX, adtMaxY],  // ADT range
    pixelMinX, pixelMinY,                   // Top-left (pixels)
    pixelMaxX, pixelMaxY                    // Bottom-right (pixels)
)
```
Maps your minimap texture pixels to world coordinates for flight masters. Usually different from DisplayBoundary.

**DisplayBoundary** - What players see
```typescript
.DisplayBoundary.setMinimapCoords(
    [adtMinX, adtMinY, adtMaxX, adtMaxY],
    pixelMinX, pixelMinY,
    pixelMaxX, pixelMaxY
)
```
Maps minimap texture to displayed UI region. Can show more/less than TaxiBoundary for aesthetic reasons.

**Scale** - Zoom level
- Lower values = more zoomed in
- Higher values = more zoomed out
- Range typically: 0.5 to 5.0
- Requires experimentation for desired look

**ContinentOffset** - UI positioning
- Shifts map display on screen
- Helps align with Azeroth/Outland/Northrend world selector buttons
- Adjust by trial and error

**World** - Which world map button
- `0` = Outland (shows when clicking Outland button)
- `1` = Azeroth (shows when clicking Azeroth button, also Northrend)

### Configuring Zone Maps

```typescript
const ZONE_MAP = std.WorldMapAreas
    .create()
    .Map.set(MY_MAP.ID)
    .Area.set(MY_ZONE.ID)
    .Directory.set('ZoneName')  // BLP texture name
    .Boundary.setMinimapCoords([1,1,6,6], minX, minY, maxX, maxY)
```

**Result:** Entry in `WorldMapArea.dbc`

**Boundary** - Zone positioning
- Defines where this zone appears on the continent map
- Uses same coordinate system as continent boundaries
- Allows clicking continent map to zoom into zone
- Multiple zones can tile together to cover the continent

---

## Understanding Boundary Coordinates

This is the most technically complex part of map UI setup.

### The Challenge

You need to map:
- Minimap texture (pixel coordinates: 0-2048)
- To world coordinates (yards: -17,066 to +17,066)
- Based on ADT tiles (grid coordinates: 0-63)

### The Solution: setMinimapCoords()

```typescript
.Boundary.setMinimapCoords(
    [adtMinX, adtMinY, adtMaxX, adtMaxY],  // Your ADT tile range
    pixelMinX, pixelMinY,                   // Top-left of content (pixels)
    pixelMaxX, pixelMaxY                    // Bottom-right of content (pixels)
)
```

TSWoW automatically converts these to world coordinates.

### The Math (Automated by TSWoW)

Located in `tswow-scripts/wotlk/std/Worldmap/MinimapCoords.ts`:

**Step 1: Convert ADT coordinates to world coordinates**
```typescript
worldLeft   = (32 - adtMinX) × 533.333333
worldTop    = (32 - adtMinY) × 533.333333
worldRight  = (31 - adtMaxX) × 533.333333
worldBottom = (31 - adtMaxY) × 533.333333
```

**Step 2: Calculate world size covered by ADTs**
```typescript
worldSizeX = worldLeft - worldRight
worldSizeY = worldTop - worldBottom
```

**Step 3: Calculate minimap size in pixels**
```typescript
minimapSizeX = (adtMaxX - adtMinX + 1) × 256
minimapSizeY = (adtMaxY - adtMinY + 1) × 256
```
Rule of thumb: Each ADT = 256 pixels on minimap

**Step 4: Map pixel positions to world positions**
```typescript
worldMinX = worldLeft - (pixelMinX / minimapSizeX) × worldSizeX
worldMinY = worldTop - (pixelMinY / minimapSizeY) × worldSizeY

worldMaxX = worldLeft - (pixelMaxX / minimapSizeX) × worldSizeX
worldMaxY = worldTop - (pixelMaxY / minimapSizeY) × worldSizeY
```

### Practical Example

```typescript
// Your map setup:
// - ADT tiles: 1-6 in both X and Y (6×6 grid)
// - Minimap texture: 1536×1536 pixels
// - Actual map content: pixels (228, 423) to (1481, 1258)

.DisplayBoundary.setMinimapCoords(
    [1, 1, 6, 6],      // 6 ADTs in each direction
    228, 423,          // Top-left of map content
    1481, 1258         // Bottom-right of map content
)

// Behind the scenes TSWoW calculates:
// - 6 ADTs = 6 × 533.33 = 3,200 yards world size
// - 6 ADTs = 6 × 256 = 1,536 pixel minimap size (perfect match!)
// - Pixel (228, 423) maps to world coords
// - Pixel (1481, 1258) maps to world coords
// - Flight masters use these world coords for paths
```

### Why This System Exists

- Flight master paths are stored in world coordinates
- World map UI displays minimap textures
- Players click pixels, game needs world coordinates
- `setMinimapCoords()` bridges these two systems

**You don't calculate world coordinates yourself** - just measure pixels on your texture!

---

## Working with Minimap Textures

### Texture Requirements

- **Format:** BLP (Blizzard Picture format)
- **Recommended sizes:** 1024×1024, 1536×1536, 2048×2048 (powers of 2)
- **Rule of thumb:** Each ADT = 256 pixels on minimap
  - 4×4 ADTs = 1024×1024
  - 6×6 ADTs = 1536×1536
  - 8×8 ADTs = 2048×2048

### Creation Workflow

**Step 1: Create Source Image**

Use any image editor to create PNG or TGA:
- **GIMP** (free, cross-platform)
- **Photoshop**
- **Krita** (free, cross-platform)
- **Paint.NET** (Windows, free)

Create your map artwork at desired resolution.

**Step 2: Measure Pixel Boundaries**

You need to measure where your actual map content is within the texture. Use an image editor.

**Visual Guide:**

```
Your 1536×1536 texture:

(0, 0) ┌─────────────────────────────────────┐
       │  Ocean / decorative border          │
       │                                     │
       │    ┌───────────────────┐           │
       │    │ Actual map        │           │
(minX, │    │ content (land,    │           │
minY)→ │    │ cities, etc.)     │           │
       │    │                   │           │
       │    └───────────────────┘ ←(maxX,   │
       │                           maxY)    │
       │  More ocean / border                │
       └─────────────────────────────────────┘ (1536, 1536)
```

**Example measurement:**
```
Content rectangle:
  Top-left: (228, 423)
  Width: 1253 pixels
  Height: 835 pixels
  
Calculated bottom-right:
  maxX = 228 + 1253 = 1481
  maxY = 423 + 835 = 1258
  
Use in code:
  .setMinimapCoords([1,1,6,6], 228, 423, 1481, 1258)
```

**Step 3: Convert to BLP**

```bash
# TSWoW includes BLPConverter
bin/BLPConverter/blpconverter -i MyMap.png -o MyMap.blp -q high

# Quality options:
# -q high   = best quality, larger file size (~1-2 MB)
# -q medium = balanced (default if omitted)
# -q low    = smallest file, visible compression artifacts
```

**Step 4: Place in Assets**

```
modules/your-mod/assets/Interface/WorldMap/
  ├── TestMap.blp          ← Continent minimap
  ├── TestIsland.blp       ← Zone minimap
  └── TestHarbor.blp       ← Another zone minimap
```

**Step 5: Reference in Datascripts**

```typescript
// For continent:
.Directory.set('TestMap')  // Looks for TestMap.blp

// For zone:
.Directory.set('TestIsland')  // Looks for TestIsland.blp
```

**Note:** Do NOT include the `.blp` extension in the Directory name.

---

## Map Overlays

Map overlays are sub-area textures drawn on top of parent zone minimaps.

### What Are Overlays?

- Small textures rendered on zone minimaps
- Used for: dungeons, sub-zones, landmarks, clickable areas
- Example: A tower icon appearing on an island's zone map
- Can be clickable to zoom/pan

### Creating an Overlay

```typescript
const OVERLAY = PARENT_WORLDMAP
    .Overlays.addGet()
    .Areas.addId(SUBZONE_ID)               // Which area triggers display
    .Texture.set('OverlayName', 512, 512)  // Texture name and dimensions
    .HitRect.set(x1, y1, x2, y2)           // Clickable region
    .Offset.setSpread(x, y)                // Position on parent map
```

**Result:** Entry in `WorldMapOverlay.dbc`

### Properties Explained

**Areas** - Activation trigger
```typescript
.Areas.addId(TOWER_AREA.ID)
```
When the player enters this area ID, the overlay appears highlighted on the map.

**Texture** - The overlay image
```typescript
.Texture.set('TestTower', 512, 512)
```
- Looks for: `Interface/WorldMap/TestTower.blp`
- Second parameter (512) = texture width in pixels
- Third parameter (512) = texture height in pixels
- Dimensions must match actual BLP file size

**HitRect** - Clickable bounds
```typescript
.HitRect.set(696, 263, 696+280, 263+265)
```
- Defines clickable rectangle on **parent map** (pixel coordinates)
- Format: `(x1, y1, x2, y2)` = top-left and bottom-right corners
- Clicking this area can zoom/focus to the overlay region

**Offset** - Positioning on parent
```typescript
.Offset.setSpread(696, 263)
```
- Where to draw the overlay on the **parent map** (pixel coordinates)
- Relative to parent map's texture, not world coordinates
- Format: `(x, y)` = top-left corner position

### Practical Example from tswow-tests

```typescript
// Parent map: Test Island zone (1024×1024 pixels)
// Child overlay: Test Tower (512×512 pixels)

const TEST_TOWER_OVERLAY = TEST_ISLAND_WORLDMAP
    .Overlays.addGet()
    .Areas.addId(TEST_TOWER.ID)
    .Texture.set('TestTower', 512, 512)
    .HitRect.set(696, 263, 696+280, 263+265)  // 280×265 clickable area
    .Offset.setSpread(696, 263)
```

**Visualization:**

```
Test Island map (1024×1024):
┌────────────────────────────────────────┐
│                                        │
│                                        │
│                   (696, 263)           │
│                   ┌──────────┐        │
│                   │ Tower    │        │
│                   │ Overlay  │        │
│                   │ 512×512  │        │
│                   └──────────┘        │
│                                        │
└────────────────────────────────────────┘
```

The overlay is drawn at position (696, 263) and spans 512 pixels in both dimensions.

### When to Use Overlays

- **Dungeon entrances** - Show dungeon icon on exterior zone map
- **Sub-areas** - Highlight specific locations within larger zones
- **Landmarks** - Towers, keeps, special buildings
- **Phased areas** - Different versions of same location

---

## Collision Data: MMaps and VMaps

### What Are MMaps and VMaps?

**VMaps (Visibility Maps)**
- Collision geometry extracted from WMO (World Map Objects) and M2 (doodad models)
- Used for: Line-of-sight checks, spell targeting, collision detection
- File format: `.vmtree` (structure) and `.vmtile` (per-tile data)
- Location: `data/vmaps/`

**MMaps (Movement Maps)**
- Navigation meshes for pathfinding
- Generated from terrain heightmaps and VMaps
- Used for: NPC movement, pet pathfinding, player pathfinding (swimming/flying)
- File format: `.mmap` (map-level) and `.mmtile` (per-tile data)
- Location: `data/mmaps/`

**Why you need them:**
- **Without VMaps:** NPCs can shoot through walls, no collision detection, broken line-of-sight
- **Without MMaps:** NPCs stand still or walk through walls, pets can't follow, broken pathfinding

### Generating VMaps

**Step 1: Extract from Client**

VMaps must be extracted from WMO and M2 files in the client:

```typescript
import { MapData } from './runtime/MapData';

// In your build script or programmatically:
MapData.vmap_assemble(dataset);
```

**What happens:**
- Reads extracted WMO/M2 geometry data
- Converts to optimized binary collision format
- Writes `.vmtree` and `.vmtile` files to `data/vmaps/`
- Server loads these at runtime for collision checks

### Generating MMaps

MMaps require both terrain data (from ADTs) and collision data (from VMaps).

```typescript
import { MapData } from './runtime/MapData';

// Generate mmaps for all maps (slow!)
MapData.mmaps(dataset);

// Generate for specific map only (recommended)
MapData.mmaps(
    dataset,           // Your dataset
    'default',         // Build type: 'default' or 'release'
    [727],            // Array of map IDs (e.g., your custom map)
    [],               // Array of tile coords (empty = all tiles)
    4                 // Thread count (parallel processing)
);
```

**What happens:**
1. Reads ADT files for terrain heightmap
2. Reads VMaps for WMO/M2 collision
3. Generates navigation mesh using Recast/Detour libraries
4. Writes `.mmap` and `.mmtile` files to `data/mmaps/`
5. Can take minutes to hours depending on map size

**Performance notes:**
- Use multiple threads (`--threads=4` or more)
- Generate only changed maps, not all maps every time
- MMaps for custom small maps: ~2-10 minutes
- MMaps for large continents: hours

### TSWoW's Role

**TSWoW provides:**
- Compiled extractor tools in `bin/core/<emulator>/`
  - `vmap4_extractor` - Extracts WMO/M2 from client
  - `vmap4_assembler` - Assembles VMaps
  - `mmaps_generator` - Generates movement maps
- API functions: `MapData.vmap_assemble()`, `MapData.mmaps()`
- Integration hooks for automated generation

**TSWoW does NOT:**
- Auto-generate on every build (too time-consuming)
- Require them for map to load (map loads, but gameplay broken)
- Regenerate automatically when terrain changes (manual step)

### Recommended Workflow

1. **Create map** - Generate ADT files with TSWoW
2. **Edit terrain** - Sculpt in Noggit
3. **Place objects** - Add WMOs and M2s in Noggit
4. **Save and build** - Build data and client
5. **Generate VMaps** - Run extractor and assembler
6. **Generate MMaps** - Run mmaps_generator for your map ID
7. **Test** - Verify NPC pathfinding and collision
8. **Regenerate when needed** - Only when terrain/objects significantly change

---

## Reference Example

The **tswow-tests** repository provides a complete, working example of custom map creation.
- **GitHub:** [github.com/tswow/tswow-tests](https://github.com/tswow/tswow-tests)
- **Location:** `datascripts/maps/`

### Learning Points

**From `map.ts`:**
- Line 26: `.Tiles.add('tswow-tests',[[1,1,6,6,'testmap']])` generates 6×6 grid = 36 ADT files
- The 5th parameter `'testmap'` creates `.tele testmap` command
- Zones and subzones use parent-child relationships via `ParentArea`

**From `worldmap.ts`:**
- Lines 36-37: Notice `TaxiBoundary` and `DisplayBoundary` use **different pixels**
- Comments say "measured" - they used image editor to measure
- Comments say "experimented" - trial and error for Scale and Offset
- Line 52: Zone boundary is measured relative to continent texture

**Overlay positioning (lines 61-66):**
- Overlay texture is 512×512
- Positioned at (696, 263) on the 1024×1024 island map
- HitRect is 280×265 pixels (clickable area)
- Shows practical example of overlay math

### Asset Structure

```
tswow-tests/assets/
├── Interface/WorldMap/
│   ├── TestMap.blp           ← Continent minimap (1536×1536)
│   ├── TestIsland.blp        ← Zone minimap
│   ├── TestHarbor.blp        ← Zone minimap
│   ├── TestIslandMain.blp    ← Overlay texture (768×768)
│   └── TestTower.blp         ← Overlay texture (512×512)
└── world/maps/testmap/
    ├── testmap.wdt           ← WDT index
    ├── testmap_1_1.adt       ← ADT tiles
    ├── testmap_1_2.adt
    └── ... (36 total ADT files)
```

### How to Explore

```bash
# Clone the repository
git clone https://github.com/tswow/tswow-tests
cd tswow-tests

# Study the datascripts
cat datascripts/maps/map.ts
cat datascripts/maps/worldmap.ts

# View the assets (requires BLP tools to view textures)
ls -la assets/Interface/WorldMap/
ls -la assets/world/maps/testmap/

# Convert BLP to PNG for viewing
# (Assuming BLPConverter is in PATH)
blpconverter -i assets/Interface/WorldMap/TestMap.blp -o TestMap.png
```